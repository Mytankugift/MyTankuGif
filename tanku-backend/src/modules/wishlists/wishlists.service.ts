import { prisma } from '../../config/database';
import { NotFoundError, BadRequestError, ForbiddenError, ConflictError } from '../../shared/errors/AppError';
import { WishListDTO, WishListItemDTO } from '../../shared/dto/wishlists.dto';
import type { WishList, WishListItem } from '@prisma/client';
import { env } from '../../config/env';
import { FeedService } from '../feed/feed.service';
import * as crypto from 'crypto';

export class WishListsService {
  private feedService: FeedService;

  constructor() {
    this.feedService = new FeedService();
  }

  /**
   * Normalizar URL de imagen
   */
  private normalizeImageUrl(imagePath: string | null | undefined): string | null {
    if (!imagePath) return null;
    const cdnBase = env.DROPI_CDN_BASE || 'https://d39ru7awumhhs2.cloudfront.net';
    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
      return imagePath;
    }
    const cleanPath = imagePath.startsWith('/') ? imagePath.substring(1) : imagePath;
    return `${cdnBase}/${cleanPath}`;
  }

  /**
   * Generar slug desde el nombre de la wishlist
   */
  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remover acentos
      .replace(/[^a-z0-9]+/g, '-') // Reemplazar caracteres especiales con guiones
      .replace(/(^-|-$)/g, '') // Remover guiones al inicio y final
      .substring(0, 100); // Limitar longitud
  }

  /**
   * Generar ID corto desde el ID completo (primeros 8 caracteres)
   */
  private generateShortId(id: string): string {
    return id.substring(0, 8);
  }

  /**
   * Mapper: WishListItem de Prisma a WishListItemDTO
   */
  private mapWishListItemToDTO(
    item: WishListItem & {
      product: { id: string; title: string; handle: string; images: string[] };
      variant?: { id: string; title: string; price: number; suggestedPrice?: number | null; tankuPrice: number | null } | null;
    }
  ): WishListItemDTO {
    return {
      id: item.id,
      productId: item.productId,
      variantId: item.variantId || null,
      variant: item.variant
        ? {
            id: item.variant.id,
            title: item.variant.title,
            tankuPrice: item.variant.tankuPrice || 0, // Precio final (tankuPrice)
          }
        : null,
      product: {
        id: item.product.id,
        title: item.product.title,
        handle: item.product.handle,
        thumbnail: this.normalizeImageUrl(item.product.images?.[0]),
      },
      createdAt: item.createdAt.toISOString(),
    };
  }

  /**
   * Mapper: WishList de Prisma a WishListDTO
   */
  private mapWishListToDTO(wishList: WishList & { items: (WishListItem & { product: { id: string; title: string; handle: string; images: string[] } })[] }): WishListDTO {
    return {
      id: wishList.id,
      userId: wishList.userId,
      name: wishList.name,
      public: wishList.public,
      items: wishList.items.map((item) => this.mapWishListItemToDTO(item)),
      createdAt: wishList.createdAt.toISOString(),
      updatedAt: wishList.updatedAt.toISOString(),
    };
  }

  /**
   * Obtener wish lists de un usuario
   */
  async getUserWishLists(userId: string): Promise<WishListDTO[]> {
    const wishLists = await prisma.wishList.findMany({
      where: {
        userId,
        isAutoGenerated: false, // ‚úÖ Excluir la wishlist autom√°tica "Me gusta"
      },
      include: {
        items: {
          include: {
            product: {
              include: {
                category: true,
                variants: {
                  where: {
                    active: true,
                  },
                  include: {
                    warehouseVariants: {
                      select: {
                        stock: true,
                      },
                    },
                  },
                  orderBy: {
                    price: 'asc',
                  },
                },
              },
            },
            variant: {
              select: {
                id: true,
                title: true,
                price: true,
                suggestedPrice: true,
                tankuPrice: true,
                sku: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return wishLists.map((list) => this.mapWishListToDTOComplete(list));
  }

  /**
   * Mapper: WishListItem con producto completo de Prisma a WishListItemDTO
   */
  private mapWishListItemToDTOComplete(
    item: WishListItem & {
      product: any; // Product con todas sus relaciones
      variant?: { id: string; title: string; price: number; suggestedPrice: number | null; tankuPrice: number | null; sku: string } | null;
    }
  ): WishListItemDTO {
    // Mapear variantes del producto completo
    const variants = item.product.variants?.map((v: any) => ({
      id: v.id,
      sku: v.sku,
      title: v.title,
      tankuPrice: v.tankuPrice || 0, // Precio final (tankuPrice)
      stock: v.warehouseVariants?.reduce((sum: number, wv: any) => sum + (wv.stock || 0), 0) || 0,
      active: v.active,
    })) || [];

    // Normalizar im√°genes
    const images = Array.isArray(item.product.images) 
      ? item.product.images.map((img: string) => this.normalizeImageUrl(img)).filter((img: string | null) => img !== null)
      : [];

    return {
      id: item.id,
      productId: item.productId,
      variantId: item.variantId || null,
      variant: item.variant
        ? {
            id: item.variant.id,
            title: item.variant.title,
            tankuPrice: item.variant.tankuPrice || 0,
          }
        : null,
      product: {
        id: item.product.id,
        title: item.product.title,
        handle: item.product.handle,
        thumbnail: this.normalizeImageUrl(item.product.images?.[0]),
        // Agregar informaci√≥n completa del producto
        images: images as string[],
        variants: variants,
        description: item.product.description || undefined,
        category: item.product.category ? {
          id: item.product.category.id,
          name: item.product.category.name,
          handle: item.product.category.handle,
        } : undefined,
        active: item.product.active !== false,
      },
      createdAt: item.createdAt.toISOString(),
    };
  }

  /**
   * Mapper: WishList con productos completos de Prisma a WishListDTO
   */
  private mapWishListToDTOComplete(wishList: WishList & { items: any[] }): WishListDTO {
    return {
      id: wishList.id,
      userId: wishList.userId,
      name: wishList.name,
      public: wishList.public,
      items: wishList.items.map((item) => this.mapWishListItemToDTOComplete(item)),
      createdAt: wishList.createdAt.toISOString(),
      updatedAt: wishList.updatedAt.toISOString(),
    };
  }

  /**
   * Crear nueva wish list
   */
  async createWishList(userId: string, name: string, isPublic: boolean = false): Promise<WishListDTO> {
    if (!name || name.trim().length === 0) {
      throw new BadRequestError('El nombre de la wish list es requerido');
    }

    const wishList = await prisma.wishList.create({
      data: {
        userId,
        name: name.trim(),
        public: isPublic,
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                title: true,
                handle: true,
                images: true,
              },
            },
            variant: {
              select: {
                id: true,
                title: true,
                price: true,
                suggestedPrice: true,
                tankuPrice: true,
              },
            },
          },
        },
      },
    });

    return this.mapWishListToDTO(wishList);
  }

  /**
   * Actualizar wish list (nombre y visibilidad)
   */
  async updateWishList(
    wishListId: string,
    userId: string,
    name?: string,
    isPublic?: boolean
  ): Promise<WishListDTO> {
    const wishList = await prisma.wishList.findUnique({
      where: { id: wishListId },
    });

    if (!wishList) {
      throw new NotFoundError('Wish list no encontrada');
    }

    if (wishList.userId !== userId) {
      throw new ForbiddenError('No tienes permiso para editar esta wish list');
    }

    const updateData: { name?: string; public?: boolean } = {};
    if (name !== undefined) {
      if (!name.trim()) {
        throw new BadRequestError('El nombre no puede estar vac√≠o');
      }
      updateData.name = name.trim();
    }
    if (isPublic !== undefined) {
      updateData.public = isPublic;
    }

    const updated = await prisma.wishList.update({
      where: { id: wishListId },
      data: updateData,
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                title: true,
                handle: true,
                images: true,
              },
            },
            variant: {
              select: {
                id: true,
                title: true,
                price: true,
                suggestedPrice: true,
                tankuPrice: true,
              },
            },
          },
        },
      },
    });

    return this.mapWishListToDTO(updated);
  }

  /**
   * Eliminar wish list
   */
  async deleteWishList(wishListId: string, userId: string): Promise<void> {
    const wishList = await prisma.wishList.findUnique({
      where: { id: wishListId },
      include: { items: true },
    });

    if (!wishList) {
      throw new NotFoundError('Wish list no encontrada');
    }

    if (wishList.userId !== userId) {
      throw new ForbiddenError('No tienes permiso para eliminar esta wish list');
    }

    // ‚úÖ Prevenir eliminar la wishlist autom√°tica "Me gusta"
    if (wishList.isAutoGenerated) {
      throw new BadRequestError('No se puede eliminar la wishlist autom√°tica "Me gusta"');
    }

    // Actualizar m√©tricas del feed para cada producto antes de eliminar
    for (const item of wishList.items) {
      try {
        const currentMetrics = await (prisma as any).itemMetric.findUnique({
          where: {
            itemId_itemType: {
              itemId: item.productId,
              itemType: 'product',
            },
          },
        });

        const currentCount = currentMetrics?.wishlistCount || 0;
        const newCount = Math.max(0, currentCount - 1);

        await this.feedService.updateItemMetricsDebounced(item.productId, 'product', {
          wishlistCount: newCount,
        });
      } catch (error) {
        console.error(`Error actualizando m√©tricas para producto ${item.productId}:`, error);
        // No fallar si la actualizaci√≥n de m√©tricas falla
      }
    }

    // Eliminar la wish list (cascade delete eliminar√° los items)
    await prisma.wishList.delete({
      where: { id: wishListId },
    });
  }

  /**
   * Agregar producto a wish list
   */
  async addItemToWishList(
    wishListId: string,
    productId: string,
    userId: string,
    variantId?: string
  ): Promise<WishListItemDTO> {
    // Verificar que la wish list existe y pertenece al usuario
    const wishList = await prisma.wishList.findUnique({
      where: { id: wishListId },
    });

    if (!wishList) {
      throw new NotFoundError('Wish list no encontrada');
    }

    if (wishList.userId !== userId) {
      throw new ForbiddenError('No tienes permiso para agregar items a esta wish list');
    }

    // Verificar que el producto existe
    const product = await prisma.product.findUnique({
      where: { id: productId },
    });

    if (!product) {
      throw new NotFoundError('Producto no encontrado');
    }

    // Si se especifica variantId, verificar que existe y pertenece al producto
    if (variantId) {
      const variant = await prisma.productVariant.findUnique({
        where: { id: variantId },
        include: {
          warehouseVariants: {
            select: {
              stock: true,
            },
          },
        },
      });

      if (!variant || variant.productId !== productId) {
        throw new BadRequestError('La variante no pertenece a este producto');
      }

      // ‚úÖ Calcular stock total desde warehouseVariants (igual que checkout y cart)
      const totalStock = variant.warehouseVariants?.reduce(
        (sum, wv) => sum + (wv.stock || 0),
        0
      ) || 0;

      // Validar que la variante tenga stock disponible
      if (totalStock === 0) {
        throw new BadRequestError('Este producto no tiene stock disponible');
      }
    } else {
      // Si NO se especifica variantId y el producto solo tiene 1 variante activa,
      // guardamos autom√°ticamente esa variante para que el item tenga precio/variante.
      // IMPORTANTE: Usar la misma l√≥gica que el feed (ordenar por price asc)
      const onlyVariant = await prisma.productVariant.findFirst({
        where: { productId, active: true },
        select: { id: true },
        orderBy: { price: 'asc' }, // Cambiar de createdAt a price para consistencia con feed
      });

      const secondVariant = await prisma.productVariant.findFirst({
        where: { productId, active: true, NOT: { id: onlyVariant?.id } },
        select: { id: true },
        orderBy: { price: 'asc' }, // Cambiar de createdAt a price para consistencia con feed
      });

      if (onlyVariant && !secondVariant) {
        // ‚úÖ Validar stock calculando desde warehouseVariants
        const variantWithStock = await prisma.productVariant.findUnique({
          where: { id: onlyVariant.id },
          include: {
            warehouseVariants: {
              select: {
                stock: true,
              },
            },
          },
        });

        if (variantWithStock) {
          const totalStock = variantWithStock.warehouseVariants?.reduce(
            (sum, wv) => sum + (wv.stock || 0),
            0
          ) || 0;

          if (totalStock === 0) {
            throw new BadRequestError('Este producto no tiene stock disponible');
          }
        }

        variantId = onlyVariant.id;
      } else if (!onlyVariant) {
        // Si el producto no tiene variantes activas, no se puede agregar
        throw new BadRequestError('El producto no tiene variantes disponibles');
      } else {
        // Si tiene m√∫ltiples variantes, se debe especificar variantId
        throw new BadRequestError('El producto tiene m√∫ltiples variantes. Por favor selecciona una variante');
      }
    }

    // Verificar que el producto no est√© ya en la wish list (mismo producto y misma variante si aplica)
    const existingItem = await prisma.wishListItem.findFirst({
      where: {
        wishListId,
        productId,
        variantId: variantId || null,
      },
    });

    if (existingItem) {
      throw new ConflictError('El producto ya est√° en esta wish list');
    }

    // Crear el item
    const item = await prisma.wishListItem.create({
      data: {
        wishListId,
        productId,
        variantId: variantId || null,
      },
      include: {
        product: {
          select: {
            id: true,
            title: true,
            handle: true,
            images: true,
          },
        },
        variant: variantId
          ? {
              select: {
                id: true,
                title: true,
                price: true,
                suggestedPrice: true,
                tankuPrice: true,
              },
            }
          : undefined,
      },
    });

    // Actualizar m√©tricas del feed
    try {
      const currentMetrics = await (prisma as any).itemMetric.findUnique({
        where: {
          itemId_itemType: {
            itemId: productId,
            itemType: 'product',
          },
        },
      });

      const currentCount = currentMetrics?.wishlistCount || 0;
      await this.feedService.updateItemMetricsDebounced(productId, 'product', {
        wishlistCount: currentCount + 1,
      });
    } catch (error) {
      console.error(`Error actualizando m√©tricas para producto ${productId}:`, error);
      // No fallar si la actualizaci√≥n de m√©tricas falla
    }

    // Crear historia autom√°tica de wishlist SOLO si la wishlist NO es autom√°tica ("Me gusta")
    if (!wishList.isAutoGenerated) {
      try {
        const { StoriesService } = await import('../stories/stories.service');
        const storiesService = new StoriesService();
        
        await storiesService.createWishlistStory({
          userId,
          wishlistId: wishList.id,
          productId,
          variantId: variantId || undefined,
        });
        
        console.log(`‚úÖ [WISHLISTS] Historia de wishlist creada para producto ${productId} en wishlist ${wishList.id}`);
      } catch (error: any) {
        // No fallar si la creaci√≥n de historia falla (puede ser por l√≠mite alcanzado)
        console.error(`‚ö†Ô∏è [WISHLISTS] Error creando historia de wishlist:`, error.message);
      }
    }

    return this.mapWishListItemToDTO(item);
  }

  /**
   * Remover producto de wish list
   */
  async removeItemFromWishList(wishListId: string, itemId: string, userId: string): Promise<void> {
    // Verificar que el item existe
    const item = await prisma.wishListItem.findUnique({
      where: { id: itemId },
      include: {
        wishList: true,
      },
    });

    if (!item) {
      throw new NotFoundError('Item no encontrado');
    }

    if (item.wishList.userId !== userId) {
      throw new ForbiddenError('No tienes permiso para remover items de esta wish list');
    }

    if (item.wishListId !== wishListId) {
      throw new BadRequestError('El item no pertenece a esta wish list');
    }

    const productId = item.productId;

    // Eliminar el item
    await prisma.wishListItem.delete({
      where: { id: itemId },
    });

    // Actualizar m√©tricas del feed
    try {
      const currentMetrics = await (prisma as any).itemMetric.findUnique({
        where: {
          itemId_itemType: {
            itemId: productId,
            itemType: 'product',
          },
        },
      });

      const currentCount = currentMetrics?.wishlistCount || 0;
      const newCount = Math.max(0, currentCount - 1);

      await this.feedService.updateItemMetricsDebounced(productId, 'product', {
        wishlistCount: newCount,
      });
    } catch (error) {
      console.error(`Error actualizando m√©tricas para producto ${productId}:`, error);
      // No fallar si la actualizaci√≥n de m√©tricas falla
    }
  }

  /**
   * Guardar wishlist de otro usuario
   */
  async saveWishlist(wishListId: string, userId: string): Promise<void> {
    // Verificar que la wishlist existe
    const wishList = await prisma.wishList.findUnique({
      where: { id: wishListId },
      include: { user: true },
    });

    if (!wishList) {
      throw new NotFoundError('Wish list no encontrada');
    }

    // No se puede guardar tu propia wishlist
    if (wishList.userId === userId) {
      throw new BadRequestError('No puedes guardar tu propia wish list');
    }

    // Verificar que no est√© ya guardada
    const existing = await prisma.savedWishlist.findUnique({
      where: {
        userId_wishListId: {
          userId,
          wishListId,
        },
      },
    });

    if (existing) {
      throw new ConflictError('Ya tienes esta wish list guardada');
    }

    // Guardar la wishlist
    await prisma.savedWishlist.create({
      data: {
        userId,
        wishListId,
      },
    });
  }

  /**
   * Desguardar wishlist
   */
  async unsaveWishlist(wishListId: string, userId: string): Promise<void> {
    const saved = await prisma.savedWishlist.findUnique({
      where: {
        userId_wishListId: {
          userId,
          wishListId,
        },
      },
    });

    if (!saved) {
      throw new NotFoundError('Wish list guardada no encontrada');
    }

    await prisma.savedWishlist.delete({
      where: {
        userId_wishListId: {
          userId,
          wishListId,
        },
      },
    });
  }

  /**
   * Obtener wishlists guardadas por el usuario
   */
  async getSavedWishlists(userId: string): Promise<WishListDTO[]> {
    // Obtener wishlists guardadas expl√≠citamente
    const saved = await prisma.savedWishlist.findMany({
      where: { userId },
      include: {
        wishList: {
          include: {
            items: {
              include: {
                product: {
                  select: {
                    id: true,
                    title: true,
                    handle: true,
                    images: true,
                  },
                },
                variant: {
                  select: {
                    id: true,
                    title: true,
                    price: true,
                    tankuPrice: true,
                  },
                },
              },
            },
            user: {
              include: {
                profile: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    // Verificar accesos aprobados para wishlists privadas
    const privateWishlistIds = saved
      .filter(s => !s.wishList.public)
      .map(s => s.wishList.id);

    let approvedWishlistIds = new Set<string>();
    if (privateWishlistIds.length > 0) {
      const approvedAccess = await prisma.wishlistAccessRequest.findMany({
        where: {
          requesterId: userId,
          status: 'approved',
          wishlistId: {
            in: privateWishlistIds,
          },
        },
        select: {
          wishlistId: true,
        },
      });
      approvedWishlistIds = new Set(approvedAccess.map((a) => a.wishlistId));
    }

    // Filtrar: solo devolver wishlists p√∫blicas O privadas con acceso aprobado
    return saved
      .filter((s) => {
        // Si es p√∫blica, siempre incluirla
        if (s.wishList.public) return true;
        // Si es privada, solo incluirla si tiene acceso aprobado
        return approvedWishlistIds.has(s.wishList.id);
      })
      .map((s) => {
        const dto = this.mapWishListToDTO(s.wishList);
        // Si es privada y no tiene acceso aprobado, ocultar items
        if (!s.wishList.public && !approvedWishlistIds.has(s.wishList.id)) {
          dto.items = [];
        }
        return {
          ...dto,
          userId: s.wishList.user.id,
          user: {
            id: s.wishList.user.id,
            firstName: s.wishList.user.firstName,
            lastName: s.wishList.user.lastName,
            email: s.wishList.user.email,
            username: s.wishList.user.username || null,
            profile: s.wishList.user.profile
              ? {
                  avatar: s.wishList.user.profile.avatar,
                  banner: s.wishList.user.profile.banner,
                  bio: s.wishList.user.profile.bio,
                }
              : null,
          },
        } as any;
      });
  }

  /**
   * Generar token de compartir para wishlist y retornar URL SEO
   */
  async generateShareToken(wishListId: string, userId: string): Promise<{ token: string; shareUrl: string }> {
    const wishList = await prisma.wishList.findUnique({
      where: { id: wishListId },
      include: {
        user: {
          select: {
            username: true,
          },
        },
      },
    });

    if (!wishList) {
      throw new NotFoundError('Wish list no encontrada');
    }

    if (wishList.userId !== userId) {
      throw new ForbiddenError('No tienes permiso para compartir esta wish list');
    }

    // Generar token √∫nico (mantener para compatibilidad con b√∫squeda)
    const token = crypto.randomBytes(32).toString('hex');

    await prisma.wishList.update({
      where: { id: wishListId },
      data: { shareToken: token },
    });

    // Generar URL SEO: /wishlists/share/{username}/{slug}-{shortId}
    const username = wishList.user.username || 'user';
    const slug = this.generateSlug(wishList.name);
    const shortId = this.generateShortId(wishListId);
    const shareUrl = `/wishlists/share/${username}/${slug}-${shortId}`;

    return { token, shareUrl };
  }

  /**
   * Obtener wishlist por token de compartir o por URL SEO (p√∫blico)
   * Acepta tanto el token antiguo como el nuevo formato: {username}/{slug}-{shortId}
   */
  async getWishlistByShareToken(tokenOrPath: string): Promise<WishListDTO | null> {
    let wishList = null;

    // Si es un token hexadecimal (64 caracteres), buscar directamente
    if (/^[a-f0-9]{64}$/i.test(tokenOrPath)) {
      wishList = await prisma.wishList.findUnique({
        where: { shareToken: tokenOrPath },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  title: true,
                  handle: true,
                  images: true,
                },
              },
              variant: {
                select: {
                  id: true,
                  title: true,
                  price: true,
                  suggestedPrice: true,
                  tankuPrice: true,
                },
              },
            },
          },
          user: {
            include: {
              profile: true,
            },
          },
        },
      });
    } else {
      // Formato SEO: {username}/{slug}-{shortId}
      // Ejemplo: "soydavidchang/mi-wishlist-cumpleanos-cmkecoi8"
      const parts = tokenOrPath.split('/');
      if (parts.length === 2) {
        const [username, slugWithId] = parts;
        // Extraer el shortId (√∫ltimos 8 caracteres despu√©s del √∫ltimo gui√≥n)
        const lastDashIndex = slugWithId.lastIndexOf('-');
        if (lastDashIndex > 0) {
          const shortId = slugWithId.substring(lastDashIndex + 1);
          
          // Buscar wishlist por username y shortId
          // Primero obtener el usuario
          const user = await prisma.user.findUnique({
            where: { username },
            select: { id: true },
          });

          if (user) {
            // Buscar wishlists del usuario que empiecen con el shortId
            const wishLists = await prisma.wishList.findMany({
              where: {
                userId: user.id,
                shareToken: { not: null }, // Solo wishlists compartidas
              },
              include: {
                items: {
                  include: {
                    product: {
                      select: {
                        id: true,
                        title: true,
                        handle: true,
                        images: true,
                      },
                    },
                    variant: {
                      select: {
                        id: true,
                        title: true,
                        price: true,
                        suggestedPrice: true,
                        tankuPrice: true,
                      },
                    },
                  },
                },
                user: {
                  include: {
                    profile: true,
                  },
                },
              },
            });

            // Encontrar la wishlist cuyo ID empieza con el shortId
            wishList = wishLists.find((wl) => wl.id.startsWith(shortId)) || null;
          }
        }
      }
    }

    if (!wishList) {
      return null;
    }

    return this.mapWishListToDTO(wishList);
  }

  /**
   * Obtener wishlists de un usuario considerando privacidad y amistad
   */
  async getUserWishListsWithPrivacy(
    targetUserId: string,
    viewerUserId?: string
  ): Promise<{ wishlists: WishListDTO[]; canViewPrivate: boolean; pendingRequestIds?: string[] }> {
    console.log(`üîç [SERVICE] getUserWishListsWithPrivacy INICIADO - targetUserId: ${targetUserId}, viewerUserId: ${viewerUserId}`);
    
    const isOwnProfile = viewerUserId === targetUserId;

    // Si es el propio perfil, devolver todas las wishlists
    if (isOwnProfile) {
      const wishLists = await this.getUserWishLists(targetUserId);
      return { wishlists: wishLists, canViewPrivate: true };
    }

    // Si no hay viewer, devolver p√∫blicas Y nombres de privadas (para que todos puedan solicitar acceso)
    if (!viewerUserId) {
      const wishLists = await this.getUserWishLists(targetUserId);
      const publicWishlists = wishLists.filter((w) => w.public);
      const privateWishlists = wishLists
        .filter((w) => !w.public)
        .map((w) => ({
          ...w,
          items: [], // Ocultar items de wishlists privadas
        }));
      
      return {
        wishlists: [...publicWishlists, ...privateWishlists],
        canViewPrivate: false,
      };
    }

    // NUEVA L√ìGICA: Las reglas son las mismas independientemente de amistad
    // - Wishlists p√∫blicas: siempre visibles
    // - Wishlists privadas: solo visibles si hay acceso aprobado
    
    // Verificar accesos aprobados a wishlists privadas (SIEMPRE, sin importar amistad)
    console.log(`üîç [WISHLISTS] Consulta de accesos aprobados - requesterId: ${viewerUserId}, targetUserId: ${targetUserId}`);
    const approvedAccess = await prisma.wishlistAccessRequest.findMany({
      where: {
        requesterId: viewerUserId,
        status: 'approved',
        wishlist: {
          userId: targetUserId,
        },
      },
      select: {
        wishlistId: true,
        status: true,
        requesterId: true,
      },
    });

    console.log(`üîç [WISHLISTS] Accesos aprobados encontrados en BD: ${approvedAccess.length}`);
    approvedAccess.forEach(a => {
      console.log(`üîç [WISHLISTS] Acceso aprobado: wishlistId=${a.wishlistId}, requesterId=${a.requesterId}, status=${a.status}`);
    });

    // Tambi√©n verificar TODOS los accesos (para debug)
    const allAccess = await prisma.wishlistAccessRequest.findMany({
      where: {
        requesterId: viewerUserId,
        wishlist: {
          userId: targetUserId,
        },
      },
      select: {
        wishlistId: true,
        status: true,
      },
    });
    console.log(`üîç [WISHLISTS] TODOS los accesos (cualquier status): ${allAccess.length}`, allAccess);

    const approvedWishlistIds = new Set(approvedAccess.map((a) => a.wishlistId));
    console.log(`üîç [WISHLISTS] approvedWishlistIds Set:`, Array.from(approvedWishlistIds));

    // Obtener solicitudes pendientes
    const pendingRequestIds = await this.getPendingRequestIds(viewerUserId, targetUserId);

    const wishLists = await this.getUserWishLists(targetUserId);
    
    console.log(`üîç [WISHLISTS] getUserWishListsWithPrivacy - viewerUserId: ${viewerUserId}, targetUserId: ${targetUserId}`);
    console.log(`üîç [WISHLISTS] Total wishlists obtenidas: ${wishLists.length}, P√∫blicas: ${wishLists.filter(w => w.public).length}, Privadas: ${wishLists.filter(w => !w.public).length}`);
    console.log(`üîç [WISHLISTS] Accesos aprobados: ${approvedWishlistIds.size}, Solicitudes pendientes: ${pendingRequestIds.length}`);

    // Log detallado de cada wishlist privada
    wishLists.filter(w => !w.public).forEach(w => {
      console.log(`üîç [WISHLISTS] Wishlist privada "${w.name}" (ID: ${w.id}) tiene ${w.items?.length || 0} items, acceso aprobado: ${approvedWishlistIds.has(w.id)}`);
      if (w.items && w.items.length > 0 && approvedWishlistIds.has(w.id)) {
        console.log(`üîç [WISHLISTS] Items de "${w.name}" con acceso:`, w.items.map(i => ({ id: i.id, productTitle: i.product?.title })));
      }
    });

    // Verificar bloqueo bidireccional si hay viewerUserId
    let blockedUserIds = new Set<string>();
    if (viewerUserId) {
      // Usuarios que el viewer bloque√≥
      const blockedByViewer = await prisma.friend.findMany({
        where: {
          userId: viewerUserId,
          status: 'blocked',
        },
        select: {
          friendId: true,
        },
      });
      blockedByViewer.forEach(b => blockedUserIds.add(b.friendId));

      // Usuarios que bloquearon al viewer
      const blockedViewer = await prisma.friend.findMany({
        where: {
          friendId: viewerUserId,
          status: 'blocked',
        },
        select: {
          userId: true,
        },
      });
      blockedViewer.forEach(b => blockedUserIds.add(b.userId));
    }

    // SIEMPRE aplicar las mismas reglas:
    // - P√∫blicas: siempre visibles con items (excepto si el due√±o est√° bloqueado)
    // - Privadas con acceso aprobado: visibles con items
    // - Privadas sin acceso: solo nombre (sin items)
    // Filtrar wishlists p√∫blicas de usuarios bloqueados
    const publicWishlists = wishLists.filter((w) => {
      if (!w.public) return false;
      // Si hay bloqueo, excluir wishlists p√∫blicas del usuario bloqueado
      if (viewerUserId && blockedUserIds.has(targetUserId)) {
        return false;
      }
      return true;
    });
    
    // Wishlists privadas con acceso aprobado (mostrar con items) - INDEPENDIENTE DE AMISTAD
    const privateWithAccess = wishLists
      .filter((w) => {
        const hasAccess = !w.public && approvedWishlistIds.has(w.id);
        if (!w.public) {
          console.log(`üîç [WISHLISTS] Wishlist privada "${w.name}" (${w.id}): hasAccess=${hasAccess}, items=${w.items?.length || 0}, approvedWishlistIds.has(${w.id})=${approvedWishlistIds.has(w.id)}`);
        }
        return hasAccess;
      });

    console.log(`üîç [WISHLISTS] Wishlists privadas con acceso aprobado: ${privateWithAccess.length}`);
    privateWithAccess.forEach(w => {
      console.log(`üîç [WISHLISTS] Wishlist "${w.name}" con acceso aprobado tiene ${w.items?.length || 0} items`);
      if (w.items && w.items.length > 0) {
        console.log(`üîç [WISHLISTS] Items de "${w.name}" con acceso:`, w.items.map(i => ({ id: i.id, productTitle: i.product?.title })));
      } else {
        console.log(`‚ö†Ô∏è [WISHLISTS] PROBLEMA: Wishlist "${w.name}" con acceso aprobado NO tiene items!`);
      }
    });

    // Wishlists privadas sin acceso (solo nombre, sin items)
    const privateWithoutAccess = wishLists
      .filter((w) => !w.public && !approvedWishlistIds.has(w.id))
      .map((w) => ({
        ...w,
        items: [], // Ocultar items
      }));

    const finalWishlists = [...publicWishlists, ...privateWithAccess, ...privateWithoutAccess];
    
    console.log(`üîç [WISHLISTS] ========== RESUMEN FINAL ==========`);
    console.log(`üîç [WISHLISTS] P√∫blicas: ${publicWishlists.length}`);
    console.log(`üîç [WISHLISTS] Privadas con acceso: ${privateWithAccess.length}`);
    console.log(`üîç [WISHLISTS] Privadas sin acceso: ${privateWithoutAccess.length}`);
    console.log(`üîç [WISHLISTS] Total final: ${finalWishlists.length}`);

    finalWishlists.forEach(w => {
      const itemsCount = Array.isArray(w.items) ? w.items.length : 0;
      console.log(`üîç [WISHLISTS] FINAL: "${w.name}" (${w.public ? 'p√∫blica' : 'privada'}) - items=${itemsCount}, id=${w.id}`);
    });

    return {
      wishlists: finalWishlists,
      canViewPrivate: approvedWishlistIds.size > 0, // true solo si hay acceso aprobado a alguna wishlist privada
      pendingRequestIds: pendingRequestIds || [], // Asegurar que siempre se devuelva
    };
  }

  /**
   * Solicitar acceso a una wishlist privada
   */
  async requestAccess(wishlistId: string, requesterId: string): Promise<void> {
    // Verificar que la wishlist existe
    const wishlist = await prisma.wishList.findUnique({
      where: { id: wishlistId },
      include: { user: true },
    });

    if (!wishlist) {
      throw new NotFoundError('Wishlist no encontrada');
    }

    // Verificar que no sea el due√±o
    if (wishlist.userId === requesterId) {
      throw new BadRequestError('No puedes solicitar acceso a tu propia wishlist');
    }

    // Verificar que la wishlist sea privada
    if (wishlist.public) {
      throw new BadRequestError('No se puede solicitar acceso a una wishlist p√∫blica');
    }

    // Verificar si ya existe una solicitud
    const existingRequest = await prisma.wishlistAccessRequest.findUnique({
      where: {
        wishlistId_requesterId: {
          wishlistId,
          requesterId,
        },
      },
    });

    if (existingRequest) {
      if (existingRequest.status === 'pending') {
        throw new ConflictError('Ya existe una solicitud pendiente para esta wishlist');
      }
      if (existingRequest.status === 'approved') {
        throw new ConflictError('Ya tienes acceso a esta wishlist');
      }
      // Si fue rechazada, permitir crear una nueva solicitud
    }

    // Crear o actualizar solicitud
    await prisma.wishlistAccessRequest.upsert({
      where: {
        wishlistId_requesterId: {
          wishlistId,
          requesterId,
        },
      },
      update: {
        status: 'pending',
        createdAt: new Date(),
        respondedAt: null,
      },
      create: {
        wishlistId,
        requesterId,
        status: 'pending',
      },
    });

    // TODO: Crear notificaci√≥n para el due√±o de la wishlist
  }

  /**
   * Obtener solicitudes de acceso pendientes para las wishlists del usuario
   */
  async getAccessRequests(ownerId: string) {
    // Obtener todas las wishlists del usuario
    const wishlists = await prisma.wishList.findMany({
      where: { userId: ownerId },
      include: {
        accessRequests: {
          where: { status: 'pending' },
          include: {
            requester: {
              select: {
                id: true,
                username: true,
                firstName: true,
                lastName: true,
                profile: {
                  select: {
                    avatar: true,
                  },
                },
              },
            },
          },
          orderBy: { createdAt: 'desc' },
        },
      },
    });

    // Aplanar las solicitudes
    const requests = wishlists.flatMap((w) =>
      w.accessRequests.map((req) => ({
        id: req.id,
        wishlistId: w.id,
        wishlistName: w.name,
        requester: {
          id: req.requester.id,
          username: req.requester.username,
          firstName: req.requester.firstName,
          lastName: req.requester.lastName,
          avatar: req.requester.profile?.avatar || null,
        },
        createdAt: req.createdAt,
      }))
    );

    return requests;
  }

  /**
   * Aprobar solicitud de acceso
   */
  async approveAccessRequest(requestId: string, ownerId: string): Promise<void> {
    const request = await prisma.wishlistAccessRequest.findUnique({
      where: { id: requestId },
      include: { wishlist: true },
    });

    if (!request) {
      throw new NotFoundError('Solicitud no encontrada');
    }

    if (request.wishlist.userId !== ownerId) {
      throw new ForbiddenError('No tienes permiso para aprobar esta solicitud');
    }

    if (request.status !== 'pending') {
      throw new BadRequestError('Esta solicitud ya fue procesada');
    }

    await prisma.wishlistAccessRequest.update({
      where: { id: requestId },
      data: {
        status: 'approved',
        respondedAt: new Date(),
      },
    });

    // TODO: Crear notificaci√≥n para el solicitante
  }

  /**
   * Rechazar solicitud de acceso
   */
  async rejectAccessRequest(requestId: string, ownerId: string): Promise<void> {
    const request = await prisma.wishlistAccessRequest.findUnique({
      where: { id: requestId },
      include: { wishlist: true },
    });

    if (!request) {
      throw new NotFoundError('Solicitud no encontrada');
    }

    if (request.wishlist.userId !== ownerId) {
      throw new ForbiddenError('No tienes permiso para rechazar esta solicitud');
    }

    if (request.status !== 'pending') {
      throw new BadRequestError('Esta solicitud ya fue procesada');
    }

    await prisma.wishlistAccessRequest.update({
      where: { id: requestId },
      data: {
        status: 'rejected',
        respondedAt: new Date(),
      },
    });

    // TODO: Crear notificaci√≥n para el solicitante
  }

  /**
   * Obtener IDs de wishlists para las que el usuario tiene solicitudes pendientes
   */
  async getPendingRequestIds(requesterId: string, targetUserId: string): Promise<string[]> {
    const requests = await prisma.wishlistAccessRequest.findMany({
      where: {
        requesterId,
        status: 'pending',
        wishlist: {
          userId: targetUserId,
        },
      },
      select: {
        wishlistId: true,
      },
    });

    return requests.map((r) => r.wishlistId);
  }

  /**
   * Cancelar una solicitud de acceso pendiente (solo el solicitante puede cancelar)
   */
  async cancelAccessRequest(wishlistId: string, requesterId: string): Promise<void> {
    // Buscar la solicitud pendiente
    const request = await prisma.wishlistAccessRequest.findUnique({
      where: {
        wishlistId_requesterId: {
          wishlistId,
          requesterId,
        },
      },
    });

    if (!request) {
      throw new NotFoundError('Solicitud no encontrada');
    }

    if (request.status !== 'pending') {
      throw new BadRequestError('Solo se pueden cancelar solicitudes pendientes');
    }

    // Eliminar la solicitud
    await prisma.wishlistAccessRequest.delete({
      where: {
        id: request.id,
      },
    });
  }

  /**
   * Obtener usuarios con acceso aprobado a una wishlist
   */
  async getWishlistAccessGrants(wishlistId: string, ownerId: string): Promise<Array<{
    userId: string;
    username: string | null;
    firstName: string | null;
    lastName: string | null;
    avatar: string | null;
    grantedAt: Date;
  }>> {
    // Verificar que la wishlist existe y pertenece al usuario
    const wishlist = await prisma.wishList.findUnique({
      where: { id: wishlistId },
    });

    if (!wishlist) {
      throw new NotFoundError('Wishlist no encontrada');
    }

    if (wishlist.userId !== ownerId) {
      throw new ForbiddenError('No tienes permiso para ver los accesos de esta wishlist');
    }

    // Obtener todas las solicitudes aprobadas para esta wishlist
    const approvedRequests = await prisma.wishlistAccessRequest.findMany({
      where: {
        wishlistId,
        status: 'approved',
      },
      include: {
        requester: {
          include: {
            profile: true,
          },
        },
      },
      orderBy: {
        respondedAt: 'desc',
      },
    });

    return approvedRequests.map((request) => ({
      userId: request.requester.id,
      username: request.requester.username,
      firstName: request.requester.firstName,
      lastName: request.requester.lastName,
      avatar: request.requester.profile?.avatar || null,
      grantedAt: request.respondedAt || request.updatedAt,
    }));
  }

  /**
   * Revocar acceso a una wishlist (cambiar solicitud aprobada a rejected)
   */
  async revokeWishlistAccess(wishlistId: string, userId: string, ownerId: string): Promise<void> {
    // Verificar que la wishlist existe y pertenece al usuario
    const wishlist = await prisma.wishList.findUnique({
      where: { id: wishlistId },
    });

    if (!wishlist) {
      throw new NotFoundError('Wishlist no encontrada');
    }

    if (wishlist.userId !== ownerId) {
      throw new ForbiddenError('No tienes permiso para revocar accesos de esta wishlist');
    }

    // Buscar la solicitud aprobada
    const request = await prisma.wishlistAccessRequest.findFirst({
      where: {
        wishlistId,
        requesterId: userId,
        status: 'approved',
      },
    });

    if (!request) {
      throw new NotFoundError('Acceso no encontrado');
    }

    // Cambiar el estado a rejected
    await prisma.wishlistAccessRequest.update({
      where: { id: request.id },
      data: {
        status: 'rejected',
        respondedAt: new Date(),
      },
    });
  }

  /**
   * Revocar todos los accesos a una wishlist
   */
  async revokeAllWishlistAccess(wishlistId: string, ownerId: string): Promise<void> {
    // Verificar que la wishlist existe y pertenece al usuario
    const wishlist = await prisma.wishList.findUnique({
      where: { id: wishlistId },
    });

    if (!wishlist) {
      throw new NotFoundError('Wishlist no encontrada');
    }

    if (wishlist.userId !== ownerId) {
      throw new ForbiddenError('No tienes permiso para revocar accesos de esta wishlist');
    }

    // Cambiar todas las solicitudes aprobadas a rejected
    await prisma.wishlistAccessRequest.updateMany({
      where: {
        wishlistId,
        status: 'approved',
      },
      data: {
        status: 'rejected',
        respondedAt: new Date(),
      },
    });
  }

  /**
   * Obtener wishlist autom√°tica "Me gusta" de un usuario
   */
  async getLikedWishlist(userId: string): Promise<WishListDTO | null> {
    const wishlist = await prisma.wishList.findFirst({
      where: {
        userId,
        isAutoGenerated: true,
      },
      include: {
        items: {
          include: {
            product: {
              include: {
                category: true,
                variants: {
                  where: { active: true },
                  include: {
                    warehouseVariants: {
                      select: {
                        stock: true,
                      },
                    },
                  },
                  orderBy: { price: 'asc' },
                },
              },
            },
            variant: {
              select: {
                id: true,
                title: true,
                price: true,
                suggestedPrice: true,
                tankuPrice: true,
                sku: true,
              },
            },
          },
          orderBy: { createdAt: 'desc' },
        },
        user: {
          include: {
            profile: true,
          },
        },
      },
    });

    if (!wishlist) {
      return null;
    }

    return this.mapWishListToDTOComplete(wishlist);
  }

  /**
   * Obtener wishlists recomendadas (plantillas b√°sicas vac√≠as)
   */
  getRecommendedWishlists(): Array<{ name: string; description: string }> {
    return [
      { name: 'Cumplea√±os', description: 'Regalos para mi cumplea√±os' },
      { name: 'Navidad', description: 'Lista de deseos navide√±os' },
      { name: 'Boda', description: 'Regalos para mi boda' },
      { name: 'Graduaci√≥n', description: 'Regalos para mi graduaci√≥n' },
      { name: 'San Valent√≠n', description: 'Regalos para San Valent√≠n' },
      { name: 'D√≠a de la Madre', description: 'Regalos para mam√°' },
      { name: 'D√≠a del Padre', description: 'Regalos para pap√°' },
      { name: 'Aniversario', description: 'Regalos para nuestro aniversario' },
    ];
  }
}

